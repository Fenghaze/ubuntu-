# 1 源码、编译程序、可执行文件

源码：使用编程语言编写的纯本文文件（`.c`, `.cpp`, `.py`），人看得懂，机器看不懂

编译程序：使用**编译器**将源码**编译**成机器看得懂的==二进制文件==，编译过程中会生成**目标文件**（`.o`, `.obj`）

有时，程序中会调用其他的外部子程序或函数库的函数，这时候，就必须要在编译过程中将函数库加进去。

编译器的做法就是将程序代码和函数库链接（link）起来，生成正确的可执行文件。

可执行文件：**在Linux中，可执行文件都是二进制文件**



# 2 Linux下编译C++源程序

## 2.1 编译

在Linux中，编译C的编译器是`gcc`，编译C++的编译器是`g++`

- `g++ *.cpp`：编译一个或多个源文件，会生成一个`a.out`可执行的二进制文件，而不是`.o`文件

  

- `g++ -c *.cpp`：编译一个或多个源文件，生成一个与源程序同名的`*.o`目标文件，不可执行

- `g++ *.o -o test `：链接一个或多个目标文件`*.o`生成一个名为`test`的二进制可执行文件



- `g++ -c *.cpp -o test`：==一步到位==，先`-c`编译一个或多个源文件，再`-o`生成可执行文件，但不会生成`.o`目标文件



==使用`-o`生成目标文件的原因:==

当有多个源文件时，且多个文件有相互调用，此时就无法直接进行编译，需要借助生成的目标文件`*.o`，将目标文件**链接**在一起，最后生成一个可执行文件



### 编译预处理

在编译时，还有一个**编译预处理**过程，这个过程时导入源代码中引用的头文件、宏定义等

`g++ -E *.cpp`：进行编译预处理，预处理结束后停止编译

预处理过的文件的 GCC 后缀为`.ii`，它可以通过 `-o` 选项来生成：`g++ -E *.cpp -o *.ii`



## 2.2 makefile和make

当有多个文件要进行编译时，如果使用命令行则会比较繁琐，而且如果经常要修改源文件，又要从头敲命令行进行编译。

makefile这个文件保存的就是编译时要使用的命令行，创建完毕后，使用`make`命令就能完成编译。

makefile基本语法：

```shell\
可执行文件名：目标文件1 目标文件2 ...
	gcc 目标文件1 目标文件2 ... -o 可执行文件名
clean：
	rm -f 目标文件1 目标文件2 ... 可执行文件名
```

- `make clean`：编译前先删除原来的文件
- `make 可执行文件名`：编译并生成可执行文件
- `make clean 可执行文件名`：一步到位，先删除再编译



**例子**：

```shell
# 有3个文件，main.cpp, haha.cpp, value.cpp
g++ -c main.cpp haha.cpp value.cpp -o test
# 每次修改其中以个源文件，都要重新输入这个命令进行编译
```

使用vim创建makefile

```shell
test: main.o haha.o value.o
	g++ main.o haha.o value.o -o test 
clean: # 删除原来生成的目标文件和可执行文件
	rm -f main.o haha.o value.o test
```

或使用shell的语法

```shell
OBJS=main.o haha.o value.o
test: ${OBJS}
	g++ ${OBJS} -o test
clean:
	rm -f ${OBJS} test`
```